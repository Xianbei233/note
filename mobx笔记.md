# 基础概念

## observable与observer

observable: 可观察的，用于修饰被观察的数据容器（状态）。被@observable修饰的数据容器（状态）会被深层观察追踪（指容器内部所有深度的key的value地址会进入一个观察列表，只有地址的变化才会触发观察者的更新，如果观察者观察的是一个基本类型值，则无法被触发更新，因为基本类型值的地址没有发生变更，与Redux系的浅层观察追踪不同。不存在的key不会进入观察列表且发生变更时不会触发通知给观察者触发更新）
observer: 观察者，用于修饰需要订阅数据容器（状态）的视图。被@observer修饰的视图才能调用被观察的数据容器（状态）相关的action\computed与reaction等衍生，否则只能（第一次）访问和（）多次更改数据容器（状态），相关衍生无法获取且视图无法触发更新（基础标签属性值为undefined除外，基础标签属性值为undefined时，相当于该标签属性不存在或未定义，标签可内部自行更改该属性状态并反映到视图上）

## Derivations(衍生)

源自状态的且不会跟状态发生更进一步相互作用的就是衍生。衍生有多种形式
* **视图**
* **衍生数据**
* **后端集成**

mobx将衍生区分成两种类型：
* **Computed values(计算值)**，使用纯函数从当前可观察状态中衍生的值，被@computed修饰的函数，其结果将有缓存且只在拥有自己的观察者（使用对象）时才会重新计算
* **Reaction(反应)**, 状态改变时需要自动发生的副作用，最终都要事先I/O操作

## Action

任何可以变更状态的操作，选用，推荐使用

## 数据流原则

**动作(Action)改变状态(State)，状态的改变会更新受影响的视图(Views)**

当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。（此处的原子级指状态在一个Action内发生多次变更，所有衍生只会根据最后的变更进行执行操作，不会显示/计算之前多次变更）

所有衍生默认都是同步更新。这意味着例如动作可以在改变状态之后直接可以安全地检查计算值。

计算值 是延迟（按需同步）更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。 如果视图不再使用，那么它会自动被垃圾回收。

所有的计算值都应该是纯净的。它们不应该用来改变状态。（指能根据状态进行纯函数的操作计算但不能对原状态发生变更操作等副作用，例如Array.prototype.slice()等会对操作对象发生变更的函数操作）


# 应用

不要把 computed 和 autorun 搞混。它们都是响应式调用的表达式，但是，如果你想响应式的产生一个可以被其它 observer 使用的值，请使用 @computed，如果你不想产生一个新值，而想要达到一个效果，请使用 autorun。 举例来说，效果是像打印日志、发起网络请求等这样命令式的副作用。

# 避坑注意

MobX 通常会对你期望的东西做出反应。 这意味着在90％的场景下，mobx “都可以工作”。 然而，在某些时候，你会遇到一个情况，它可能不会像你所期望的那样工作。 在这个时候理解 MobX 如何确定对什么有反应就显得尤为重要。

MobX 会对在追踪函数执行过程中读取现存的可观察属性做出反应。

“读取” 是对象属性的间接引用，可以用过 .操作符 (例如 user.name) 或者 [] (例如 user['name']) 的形式完成。
“追踪函数” 是 computed 表达式、observer 组件的 render() 方法和 when、reaction 和 autorun 的第一个入参函数。
“过程(during)” 意味着只追踪那些在函数执行时被读取的 observable 。这些值是否由追踪函数直接或间接使用并不重要。
换句话说，MobX 不会对其作出反应:

从 observable 获取的值，但是在追踪函数之外
在异步调用的代码块中读取的 observable